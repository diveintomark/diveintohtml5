<!DOCTYPE html>
<head>
<meta charset=utf-8>
<title>Let&#8217;s Call It a Draw(ing Surface) - Dive Into HTML 5</title>
<!--[if IE]><script src=j/ie.js></script><![endif]-->
<link rel=stylesheet href=screen.css>
<style>
body{counter-reset:h1 4}
table{width:100%;border-collapse:collapse}
tbody th,thead th.l,tfoot td{text-align:left}
thead th,td{text-align:center}
tfoot{font-size:small}
</style>
<meta name=viewport content="initial-scale=1.0">
</head>
<div id=body>
<p>You are here: <a href=index.html>Home</a> <span class=u>&#8227;</span> <!--<a href=table-of-contents.html#canvas>-->Dive Into HTML 5<!--</a>--> <span class=u>&#8227;</span>
<blockquote class='pf note'>
<p>This is an excerpt from &#8220;Dive Into HTML 5&#8221; which will be published in early 2010 by O&#8217;Reilly. The book will cover features from the upcoming <abbr>HTML</abbr> 5 specification and other emerging standards. HTML 5 is still a work-in-progress; browser support is listed at the beginning of each section.
</blockquote>
<h1>Let&#8217;s Call It A Draw(ing Surface)</h1>
<p id=toc>&nbsp;
<p class=a>&#x2042;
<h2 id=divingin>Diving In</h2>

<p class=f><img src=i/aoc-h.png alt=H width=106 height=105>TML 5 defines <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html>the &lt;canvas> element</a> as &#8220;a resolution-dependent bitmap canvas which can be used for rendering graphs, game graphics, or other visual images on the fly.&#8221; A <dfn>canvas</dfn> is a rectangle in your page where you can use JavaScript to draw anything you want.</p>

<table class=bc>
<caption>Basic &lt;canvas> support</caption>
<thead>
<tr><th title="Internet Explorer 8">IE8<sup>*</sup><th title="Internet Explorer 7">IE7<sup>*</sup><th title="Firefox 3.5">Fx3.5<th title="Firefox 3.0">Fx3.0<th title="Safari 4">Saf4<th title="Safari 3">Saf3<th title="Google Chrome 3">Chr3<th title="Opera 10">Op10
</thead>
<tbody>
<tr><td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;
</tbody>
<tfoot>
<tr><td colspan=8>* Internet Explorer support requires the third-party <a href=http://code.google.com/p/explorercanvas/>explorercanvas</a> library.
</tfoot>
</table>

<p class=clear>So what does a canvas look like? Nothing, really. A <code>&lt;canvas></code> element has no content and no border of its own.</p>

<canvas width=300 height=225 class=clear style="float:left"></canvas>
<p class="legend right" style="margin-top:4em"><span class=arrow>&nbsp;&#x219c;</span> Invisible canvas

<p class=clear>The markup looks like this:

<pre><code>&lt;canvas width="300" height="225">&lt;/canvas></code></pre>

<p>Let&#8217;s add a dotted border so we can see what we&#8217;re dealing with.</p>

<canvas width=300 height=225 class=clear style="border:1px dotted;float:left"></canvas>
<p class="legend right" style="margin-top:4em"><span class=arrow>&nbsp;&#x219c;</span> Canvas with border

<p class=clear>You can have several <code>&lt;canvas></code> elements on the same page. Each canvas will show up in the <abbr>DOM</abbr>, and each canvas maintains its own state. If you give each canvas an <code>id</code> attribute, you can access them just like any other element.

<p>Let&#8217;s expand that markup to include an <code>id</code> attribute:

<pre><code>&lt;canvas id="a" width="300" height="225">&lt;/canvas></code></pre>

<p>Now you can easily find that <code>&lt;canvas></code> element in the <abbr>DOM</abbr>.

<pre><code>var a_canvas = document.getElementById("a");</code></pre>

<p class=a>&#x2042;

<h2 id=shapes>Simple Shapes</h2>

<table class=bc>
<thead>
<tr><th title="Internet Explorer 8">IE8<sup>*</sup><th title="Internet Explorer 7">IE7<sup>*</sup><th title="Firefox 3.5">Fx3.5<th title="Firefox 3.0">Fx3.0<th title="Safari 4">Saf4<th title="Safari 3">Saf3<th title="Google Chrome 3">Chr3<th title="Opera 10">Op10
</thead>
<tbody>
<tr><td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;
</tbody>
<tfoot>
<tr><td colspan=8>* Internet Explorer support requires the third-party <a href=http://code.google.com/p/explorercanvas/>explorercanvas</a> library.
</tfoot>
</table>

<p>Every canvas starts out blank. That&#8217;s boring! Let&#8217;s draw something.</p>

<canvas id=b width=300 height=225 style="border:1px dotted;float:left" onclick="draw_b();return false"></canvas>
<p class="legend right" style="margin-top:4em"><span class=arrow>&nbsp;&#x21dc;</span> <a href="#" onclick="draw_b();return false">Click to draw on this canvas</a></p>

<p class=clear>The <code>onclick</code> handler called this function:

<pre><code>function draw_b() {
  var b_canvas = document.getElementById("b");
  var b_context = b_canvas.getContext("2d");
  b_context.fillRect(50, 25, 150, 100);
}</code></pre>

<p>The 1<sup>st</sup> line of the function is nothing special; it just finds the <code>&lt;canvas></code> element in the <abbr>DOM</abbr>.

<p class="legend left" style="margin-top:2em">And then there&#8217;s this <span class=arrow>&#x21dd;</span>&nbsp;</p>
<pre><code>function draw_b() {
  var b_canvas = document.getElementById("b");
<mark>  var b_context = b_canvas.getContext("2d");</mark>
  b_context.fillRect(50, 25, 150, 100);
}</code></pre>

<p class=ss><img src=i/openclipart.org_media_files_johnny_automatic_4145.png width=312 height=300 alt="man drawing in front of a mirror">

<p>Every canvas has a drawing <dfn>context</dfn>, which is where all the fun stuff happens. Once you&#8217;ve found a <code>&lt;canvas></code> element in the <abbr>DOM</abbr> (by using <code>document.getElementById()</code> or any other method you like), you call its <code>getContext()</code> method. You <strong>must</strong> pass the string <code>"2d"</code> to the <code>getContext()</code> method.

<blockquote class=note>
<p><span>&#x261E;</span>Q: Is there a 3-D canvas?<br>
A: Not yet. Individual vendors have experimented with their own three-dimensional canvas APIs, but none of them have been standardized. The HTML 5 specification notes, &#8220;A future version of this specification will probably define a 3d context.&#8221;
</blockquote>

<p>You have a <code>&lt;canvas></code> element, and you have its drawing context. The drawing context is where all the drawing methods and properties are defined. There&#8217;s a whole group of methods devoted to drawing rectangles:

<ul>
<li>The <code>fillStyle</code> property can be a <abbr>CSS</abbr> color, a pattern, or a gradient. (More on patterns and gradients shortly.) The default <code>fillStyle</code> is solid black, but you can set it to whatever you like. Each canvas remembers its own properties as long as the page is open.
<li><code>fillRect(x, y, width, height)</code> draws a rectangle filled with the current fill style.
<li>The <code>strokeStyle</code> property is like <code>fillStyle</code> &mdash; it can be a CSS color, pattern, or gradient.
<li><code>strokeRect(x, y, width, height)</code> draws an rectangle with the current stroke style. <code>strokeRect</code> doesn&#8217;t fill in the middle; it just draws the edges.
<li><code>clearRect(x, y, width, height)</code> clears the pixels in the specified rectangle.
</ul>

<p>Getting back to that code sample in the previous example&hellip;
<p class="legend left" style="margin-top:2em">Draw a rectangle <span class=arrow>&#x21dd;&nbsp;</span></p>
<pre><code>var b_canvas = document.getElementById("b");
var b_context = b_canvas.getContext("2d");
<mark>b_context.fillRect(50, 25, 150, 100);</mark></code></pre>

<p class=clear>Calling the <code>fillRect()</code> method draws the rectangle and fills it with the current fill style, which is black until you change it. The rectangle is bounded by its upper-left corner (50,&nbsp;25), its width (150), and its height (100). To get a better picture of how that works, let&#8217;s look at the canvas coordinate system.

<p class=a>&#x2042;

<h2 id=coordinates>Canvas Coordinates</h2>

<p>The canvas is a two-dimensional grid. The coordinate (0, 0) is at the upper-left corner of the canvas. Along the X-axis, values increase towards the right edge of the canvas. Along the Y-axis, values increase towards the bottom edge of the canvas.

<p class="legend top" style="width:500px;text-align:center">Canvas coordinates diagram <span class=arrow>&#x21b7;</span><br></p>
<canvas id=c width=500 height=375></canvas>

<p>That coordinate diagram was drawn with a <code>&lt;canvas></code> element. It comprises

<ul>
<li>a set of off-white vertical lines
<li>a set of off-white horizontal lines
<li>two black horizontal lines
<li>two small black diagonal lines that form an arrow
<li>two black vertical lines
<li>two small black diagonal lines that form another arrow
<li>the letter &#8220;x&#8221;
<li>the letter &#8220;y&#8221;
<li>the text &#8220;(0, 0)&#8221; near the upper-left corner
<li>the text &#8220;(500, 375)&#8221; near the lower-right corner
<li>a dot in the upper-left corner, and another in the lower-right corner
</ul>

<p>First, we need to define the <code>&lt;canvas></code> element itself. The <code>&lt;canvas></code> element defines the <code>width</code> and <code>height</code>, and the <code>id</code> so we can find it later.

<pre><code>&lt;canvas id="c" width="500" height="375">&lt;/canvas></code></pre>

<p>Then we need a script to find the <code>&lt;canvas></code> element in the DOM and get its drawing context.

<pre><code>var c_canvas = document.getElementById("c");
var context = c_canvas.getContext("2d");</code></pre>

<p>Now we can start drawing lines.

<p class=a>&#x2042;

<h2 id=paths>Paths</h2>

<table class=bc>
<thead>
<tr><th title="Internet Explorer 8">IE8<sup>*</sup><th title="Internet Explorer 7">IE7<sup>*</sup><th title="Firefox 3.5">Fx3.5<th title="Firefox 3.0">Fx3.0<th title="Safari 4">Saf4<th title="Safari 3">Saf3<th title="Google Chrome 3">Chr3<th title="Opera 10">Op10
</thead>
<tbody>
<tr><td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;
</tbody>
<tfoot>
<tr><td colspan=8>* Internet Explorer support requires the third-party <a href=http://code.google.com/p/explorercanvas/>explorercanvas</a> library.
</tfoot>
</table>

<p style="float:left;margin:1.75em 1.75em 1.75em 0"><img src=i/openclipart.org_media_files_johnny_automatic_7563.png alt="gerbil sitting on a chair with a quill and ink jar" width=167 height=347>

<p>Imagine you&#8217;re drawing a picture in ink. You don&#8217;t want to just dive in and start drawing with ink, because you might make a mistake. So you sketch lines and curves with a pencil, and once you&#8217;re happy with it, you trace over your sketch in ink.

<p>Each canvas has a <dfn>path</dfn>. Defining the path is like drawing with a pencil. You can draw whatever you like, but it won&#8217;t be part of the finished product until you pick up the quill and trace over your path in ink.

<p>To draw straight lines in pencil:

<ol style="list-style-position:inside">
<li><code>moveTo(x, y)</code> moves the pencil to the starting point.
<li><code>lineTo(x, y)</code> draws a line to an ending point.
<li>Go to step 1.
</ol>

<p>The more you call <code>moveTo()</code> and <code>lineTo()</code>, the bigger the path gets. These are &#8220;pencil&#8221; methods &mdash; you can call them as often as you like, but you won&#8217;t see anything on the canvas until you call one of the &#8220;ink&#8221; methods.

<p>Let&#8217;s draw the off-white grid.

<pre style="float:left"><code>for (var x = 0; x &lt; 500; x += 10) {
  context.moveTo(x, 0);
  <mark>context.lineTo(x, 375);</mark>
}</code></pre>
<p class="legend right" style="margin-top:4em"><span class=arrow>&nbsp;&#x21dc;</span> Draw vertical lines</p>

<pre style="clear:left;float:left"><code>for (var y = 0; y &lt; 375; y += 10) {
  context.moveTo(0, y);
  <mark>context.lineTo(500, y);</mark>
}</code></pre>
<p class="legend right" style="margin-top:4em"><span class=arrow>&nbsp;&#x21dc;</span> Draw horizontal lines</p>

<p class=clear>Those were all &#8220;pencil&#8221; methods. Nothing has actually been drawn on the canvas yet. We need an &#8220;ink&#8221; method to make it permanent.

<pre><code>context.strokeStyle = "#eee";
<mark>context.stroke();</mark></code></pre>

<p><code>stroke()</code> is one of the &#8220;ink&#8221; methods. It takes the complex path you defined with all those <code>moveTo()</code> and <code>lineTo()</code> calls, and it actually draws it on the canvas. The <code>strokeStyle</code> controls the color of the lines, and this is the result:</p>

<canvas id=c2 width=500 height=375></canvas>

<p>Now let&#8217;s draw the horizontal arrow. All the lines and curves on a path are drawn in the same color (or pattern, or gradient &mdash; yes, we&#8217;ll get to those soon). We want to draw the arrow in a different color ink &mdash; black instead of off-white &mdash; so we need to start a new path.

<p class="legend top" style="margin-left:2em">A new path <span class=arrow>&#x21b7;</span><br></p>
<pre><code><mark>context.beginPath();</mark>
context.moveTo(0, 40);
context.lineTo(240, 40);
context.moveTo(260, 40);
context.lineTo(500, 40);
context.moveTo(495, 35);
context.lineTo(500, 40);
context.lineTo(495, 45);</code></pre>

<p>The vertical arrow looks much the same. Since the vertical arrow is the same color as the horizontal arrow, we do <strong>not</strong> need to start another new path. The two arrows will be part of the same path.

<pre style="float:left"><code>context.moveTo(60, 0);
context.lineTo(60, 153);
context.moveTo(60, 173);
context.lineTo(60, 375);
context.moveTo(65, 370);
context.lineTo(60, 375);
context.lineTo(55, 370);</code></pre>
<p class="legend right" style="margin-top:4em"><span class=arrow>&nbsp;&#x219c;</span> Not a new path</p>

<p class=clear>I said these arrows were going to be black, but the <code>strokeStyle</code> is still off-white. (The <code>fillStyle</code> and <code>strokeStyle</code> don&#8217;t get reset when you start a new path.) That&#8217;s OK, because we&#8217;ve just run a series of &#8220;pencil&#8221; methods. But before we draw it for real, in &#8220;ink,&#8221; we need to set the <code>strokeStyle</code> to black. Otherwise, these two arrows will be off-white, and we could hardly see them!

<pre><code>context.strokeStyle = "#000";
context.stroke();</code></pre>

<p>And this is the result:</p>

<canvas id=c3 width=500 height=375></canvas>

<p class=a>&#x2042;

<h2 id=text>Text</h2>

<table class=bc>
<thead>
<tr><th title="Internet Explorer 8">IE8<sup>*</sup><th title="Internet Explorer 7">IE7<sup>*</sup><th title="Firefox 3.5">Fx3.5<th title="Firefox 3.0">Fx3.0<th title="Safari 4">Saf4<th title="Safari 3">Saf3<th title="Google Chrome 3">Chr3<th title="Opera 10">Op10
</thead>
<tbody>
<tr><td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2717;<td>&#x2713;<td>&#x2717;<td>&#x2713;<td>&#x2717;
</tbody>
<tfoot>
<tr><td colspan=8>* Internet Explorer support requires the third-party <a href=http://code.google.com/p/explorercanvas/>explorercanvas</a> library.
</tfoot>
</table>

<p>You can draw <a href=#paths>lines on a canvas</a>. You can also draw text on a canvas. Unlike text on the surrounding web page, there is no box model. That means none of the familiar CSS layout techniques are available: no floats, no margins, no padding, no word wrapping. (Maybe you think that&#8217;s a good thing!) You can set a few font attributes, then you pick a point on the canvas and draw your text there.

<p>The following font attributes are available on the <a href=#shapes>drawing context</a>:

<ul>
<li><code>font</code> can be anything you would put in a <abbr>CSS</abbr> <code>font</code> rule. That includes font style, font variant, font weight, font size, line height, and font family.
<li><code>textAlign</code> controls text alignment. It is similar (but not identical) to a <abbr>CSS</abbr> <code>text-align</code> rule. Possible values include <code>start</code>, <code>end</code>, <code>left</code>, <code>right</code>, and <code>center</code>.
<li><code>textBaseline</code> controls where the text is drawn relative to the starting point. Possible values are <code>top</code>, <code>hanging</code>, <code>middle</code>, <code>alphabetic</code>, <code>ideographic</code>, or <code>bottom</code>.
</ul>

<p><code>textBaseline</code> is tricky, because text is tricky. Well, English text is not tricky, but you can draw any Unicode character you like on a canvas, and Unicode is tricky. The HTML 5 specification <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-textbaseline>explains the different text baselines</a>:

<blockquote cite=http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-textbaseline>
<p>The top of the em square is roughly at the top of the glyphs in a font, the hanging baseline is where some glyphs like <span class=u>आ</span> are anchored, the middle is half-way between the top of the em square and the bottom of the em square, the alphabetic baseline is where characters like <span class=u>Á</span>, <span class=u>ÿ</span>, <span class=u>f</span>, and <span class=u>Ω</span> are anchored, the ideographic baseline is where glyphs like <span class=u>私</span> and <span class=u>達</span> are anchored, and the bottom of the em square is roughly at the bottom of the glyphs in a font. The top and bottom of the bounding box can be far from these baselines, due to glyphs extending far outside the em square.</p>
<p><img src=i/baselines.png alt="diagram of different values of the textBaseline property" width=680 height=227>
</blockquote>

<p>For simple alphabets like English, you can safely stick with <code>top</code>, <code>middle</code>, or <code>bottom</code> for the <code>textBaseline</code> property.

<p>Let&#8217;s draw some text! Text drawn inside the canvas inherits the font size and style of the <code>&lt;canvas></code> element itself, but you can override this by setting the <code>font</code> property on the drawing context.

<pre style="float:left"><code><mark>context.font = "bold 12px sans-serif";</mark>
context.fillText("x", 248, 43);
context.fillText("y", 58, 165);</code></pre>
<p class="legend right"><span class=arrow>&nbsp;&#x219c;</span> Change the font style</p>

<p class=clear>The <code>fillText()</code> method draws the actual text.</p>

<pre style="float:left"><code>context.font = "bold 12px sans-serif";
<mark>context.fillText("x", 248, 43);</mark>
context.fillText("y", 58, 165);</code></pre>
<p class="legend right" style="margin-top:2.6em"><span class=arrow>&nbsp;&#x21dc;</span> Draw the text</p>

<div class="pf clear" id=relative-font-size>
<blockquote class=note>
<p><span>&#x261E;</span>Q: Can I use relative font sizes to draw text on a canvas?<br>
A: Yes. Like every other <abbr>HTML</abbr> element on your page, the <code>&lt;canvas></code> element itself has a computed font size based on your page&#8217;s CSS rules. If you set the <code>context.font</code> property to a relative font size like <code>1.5em</code> or <code>150%</code>, your browser multiplies this by the computed font size of the <code>&lt;canvas></code> element itself.
</blockquote>
</div>

<p>For the text in the upper-left corner, I want the top of the text to be at <code>y=5</code>. But I&#8217;m lazy &mdash; I don&#8217;t want to measure the height of the text and calculate the baseline. Instead, I can set the <code>textBaseline</code> to <code>top</code> and pass in the upper-left coordinate of the text&#8217;s bounding box.

<pre><code>context.textBaseline = "top";
context.fillText("( 0 , 0 )", <mark>8, 5</mark>);</code></pre>

<p>For the text in the lower-right corner, I want to be lazy again. I want the bottom-right corner of the text to be at coordinates <code>(492,370)</code> &mdash; just a few pixels away from the bottom-right corner of the canvas &mdash; but I don&#8217;t want to measure the width or height of the text. I can set <code>textAlign</code> to <code>right</code> and <code>textBaseline</code> to <code>bottom</code>, then call <code>fillText()</code> with the bottom-right coordinates of the text&#8217;s bounding box.

<pre><code>context.textAlign = "right";
context.textBaseline = "bottom";
context.fillText("( 500 , 375 )", <mark>492, 370</mark>);</code></pre>

<p>And this is the result:</p>

<canvas id=c4 width=500 height=375></canvas>

<p>Oops! We forgot the dots in the corners. I&#8217;m going to cheat a little and <a href=#shapes>draw them as rectangles</a>. We&#8217;ll see how to draw circles a little later.

<pre style="float:left"><code>context.fillRect(0, 0, 3, 3);
context.fillRect(497, 372, 3, 3);</code></pre>
<p class="legend right"><span class=arrow>&nbsp;&#x21dc;</span> Draw two &#8220;dots&#8221;</p>

<p>And that&#8217;s all she wrote!</p>

<canvas id=c5 width=500 height=375 class=clear></canvas>

<p class=a>&#x2042;

<h2 id=gradients>Gradients &amp; Patterns</h2>

<table class=bc>
<thead>
<tr><th class=l>Feature</th><th title="Internet Explorer 8">IE8<sup>*</sup><th title="Internet Explorer 7">IE7<sup>*</sup><th title="Firefox 3.5">Fx3.5<th title="Firefox 3.0">Fx3.0<th title="Safari 4">Saf4<th title="Safari 3">Saf3<th title="Google Chrome 3">Chr3<th title="Opera 10">Op10
</thead>
<tbody>
<tr><th>linear gradients</th><td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;
<tr><th>radial gradients</th><td>&#x2717;<td>&#x2717;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;
</tbody>
<tfoot>
<tr><td colspan=9>* Internet Explorer support requires the third-party <a href=http://code.google.com/p/explorercanvas/>explorercanvas</a> library.
</tfoot>
</table>

<p>Earlier in this chapter, you learned how to draw <a href=#shapes>a rectangle filled with a solid color</a>, then <a href=#paths>a line stroked with a solid color</a>. But shapes and lines aren&#8217;t limited to solid colors. You can do all kinds of magic with gradients and patterns.</p>

<canvas id=d width=300 height=225></canvas>

<p>The markup looks the same as any other canvas.

<pre><code>&lt;canvas id="d" width="300" height="225">&lt;/canvas></code></pre>

<p>First, we need to find the <code>&lt;canvas></code> element and its drawing context.

<pre><code>var d_canvas = document.getElementById("d");
var context = d_canvas.getContext("2d");</code></pre>

<p>Once we have the drawing context, we can start to define a gradient. A <dfn>gradient</dfn> is a smooth transition between two or more colors. The canvas drawing context supports two types of gradients:

<ol>
<li><code>createLinearGradient(x0, y0, x1, y1)</code> paints along a line from (x0, y0) to (x1, y1).
<li><code>createRadialGradient(x0, y0, r0, x1, y1, r1)</code> paints along a cone between two circles. The first three parameters represent the start circle, with origin (x0, y0) and radius r0. The last three parameters represent the end circle, with origin (x1, y1) and radius r1.
</ol>

<p>Let&#8217;s make a linear gradient. Gradients can be any size, but I&#8217;ll make this gradient be 300 pixels wide, like the canvas.

<p class="legend top" style="margin-left:2.5em">Create a gradient object <span class=arrow>&#x21b7;</span><br></p>
<pre><code>var my_gradient = <mark>context.createLinearGradient(0, 0, 300, 0);</mark></code></pre>

<p>Because the <code>y</code> values (the 2<sup>nd</sup> and 4<sup>th</sup> parameters) are both 0, this gradient will shade evenly from left to right.

<p>Once we have a gradient object, we can define the gradient&#8217;s colors. A gradient has two or more <dfn>color stops</dfn>. Color stops can be anywhere along the gradient. To add a color stop, you need to specify its position along the gradient. Gradient positions can be anywhere between 0 to 1.

<p>Let&#8217;s define a gradient that shades from black to white.

<pre><code>my_gradient.addColorStop(0, "black");
my_gradient.addColorStop(1, "white");</code></pre>

<p>Defining a gradient doesn&#8217;t draw anything on the canvas. It&#8217;s just an object tucked away in memory somewhere. To draw a gradient, you set your <code>fillStyle</code> to the gradient and draw a shape, like a rectangle or a line.

<p class="legend top">Fill style is a gradient <span class=arrow>&#x21b7;</span><br></p>
<pre><code><mark>context.fillStyle = my_gradient;</mark>
context.fillRect(0, 0, 300, 225);</code></pre>

<p>And this is the result:</p>

<canvas id=d2 width=300 height=225></canvas>

<p>Suppose you want a gradient that shades from top to bottom. When you create the gradient object, keep the <code>x</code> values (1<sup>st</sup> and 3<sup>rd</sup> parameters) constant, and make the <code>y</code> values (2<sup>nd</sup> and 4<sup>th</sup> parameters) range from 0 to the height of the canvas.

<p class="legend top" style="margin-left:6.5em">x values are 0, y values vary <span class=arrow>&#x21b7;</span><br></p>
<pre><code>var my_gradient = context.createLinearGradient(<mark>0, 0, 0, 225</mark>);
my_gradient.addColorStop(0, "black");
my_gradient.addColorStop(1, "white");
context.fillStyle = my_gradient;
context.fillRect(0, 0, 300, 225);</code></pre>

<p>And this is the result:</p>

<canvas id=d3 width=300 height=225></canvas>

<p>You can also create gradients along a diagonal.

<p class="legend top" style="margin-left:8.5em">both x and y values vary <span class=arrow>&#x21b7;</span><br></p>
<pre><code>var my_gradient = context.createLinearGradient(<mark>0, 0, 300, 225</mark>);
my_gradient.addColorStop(0, "black");
my_gradient.addColorStop(1, "white");
context.fillStyle = my_gradient;
context.fillRect(0, 0, 300, 225);</code></pre>

<p>And this is the result:</p>

<canvas id=d4 width=300 height=225></canvas>

<p class=a>&#x2042;

<h2 id=images>Images</h2>

<table class=bc>
<thead>
<tr><th title="Internet Explorer 8">IE8<sup>*</sup><th title="Internet Explorer 7">IE7<sup>*</sup><th title="Firefox 3.5">Fx3.5<th title="Firefox 3.0">Fx3.0<th title="Safari 4">Saf4<th title="Safari 3">Saf3<th title="Google Chrome 3">Chr3<th title="Opera 10">Op10
</thead>
<tbody>
<tr><td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;<td>&#x2713;
</tbody>
<tfoot>
<tr><td colspan=8>* Internet Explorer support requires the third-party <a href=http://code.google.com/p/explorercanvas/>explorercanvas</a> library.
</tfoot>
</table>

<p>Here is a cat:

<p style="float:left"><img src=i/openclipart.org_media_files_johnny_automatic_1360.png alt="sleeping cat" width=177 height=113 id=cat>
<p class="legend right" style="margin-top:4em"><span class=arrow>&nbsp;&#x21dc;</span> An &lt;img> element</p>

<p class=clear>Here is the same cat, drawn on a canvas:

<div style="float:right">
<p class="legend left" style="margin-top:2em">A &lt;canvas> element <span class=arrow>&#x21dd;&nbsp;</span></p>
<canvas id=e width=177 height=113></canvas>
</div>

<p class=clear>The canvas drawing context defines several methods for drawing an image on a canvas.

<ul>
<li><code>drawImage(image, dx, dy)</code> takes an image and draws it on the canvas. The given coordinates <code>(dx, dy)</code> will be the upper-left corner of the image. Coordinates <code>(0, 0)</code> would draw the image at the upper-left corner of the canvas.
<li><code>drawImage(image, dx, dy, dw, dh)</code> takes an image, scales it to a width of <code>dw</code> and a height of <code>dh</code>, and draws it on the canvas at coordinates <code>(dx, dy)</code>.
<li><code>drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh)</code> takes an image, clips it to the rectangle <code>(sx, sy, sw, sh)</code>, scales it to dimensions <code>(dw, dh)</code>, and draws it on the canvas at coordinates <code>(dx, dy)</code>.
</ul>

<p>The HTML 5 specification <a href=http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#images>explains the <code>drawImage()</code> parameters</a>:

<blockquote cite=http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#images>
<p>The source rectangle is the rectangle [within the source image] whose corners are the four points <code>(sx, sy)</code>, <code>(sx+sw, sy)</code>, <code>(sx+sw, sy+sh)</code>, <code>(sx, sy+sh)</code>.
<p>The destination rectangle is the rectangle [within the canvas] whose corners are the four points <code>(dx, dy)</code>, <code>(dx+dw, dy)</code>, <code>(dx+dw, dy+dh)</code>, <code>(dx, dy+dh)</code>.
<p><img src=i/drawImage.png alt="diagram of drawImage parameters" width=327 height=330>
</blockquote>

<p>To draw an image on a canvas, you need an image. The image can be an existing <code>&lt;img></code> element, or you can create an <code>Image()</code> object with JavaScript. Either way, you need to ensure that the image is fully loaded before you can draw it on the canvas.

<p>If you&#8217;re using an existing <code>&lt;img></code> element, you can safely draw it on the canvas during the <code>window.onload</code> event.
<p class="legend top" style="margin-left:6.5em"><span class=arrow>&#x21b6;</span> using an &lt;img> element<br></p>
<pre><code>&lt;img <mark>id="cat"</mark> src="images/cat.png" alt="sleeping cat" width="177" height="113">
&lt;canvas id="e" width="177" height="113">
&lt;script>
<mark>window.onload</mark> = function() {
  var canvas = document.getElementById("e");
  var context = canvas.getContext("2d");
  var cat = document.getElementById("cat");
  <mark>context.drawImage(cat, 0, 0);</mark>
};
&lt;/script></code></pre>

<p>If you&#8217;re creating the image object entirely in JavaScript, you can safely draw the image on the canvas during the <code>Image.onload</code> event.

<p class="legend top" style="margin-left:3.5em">using an Image() object <span class=arrow>&#x21b7;</span><br></p>
<pre><code>&lt;canvas id="e" width="177" height="113">
&lt;script>
  var canvas = document.getElementById("e");
  var context = canvas.getContext("2d");
  var cat = <mark>new Image()</mark>;
  cat.src = "images/cat.png";
  <mark>cat.onload</mark> = function() {
    context.drawImage(cat, 0, 0);
  };
&lt;/script></code></pre>

<p>The optional 3<sup>rd</sup> and 4<sup>th</sup> parameters to the <code>drawImage()</code> method control image scaling. This is the same image, scaled to half its width and height and drawn repeatedly at different coordinates within a single canvas.</p>

<canvas id=multicat width=500 height=375></canvas>

<p>Here is the script that produces the &#8220;multicat&#8221; effect:

<pre style="float:left"><code>cat.onload = function() {
  for (var x = 0, y = 0;
       x &lt; 500, y &lt; 375;
       x += 50, y += 37) {
    context.drawImage(cat, x, y, <mark>88, 56</mark>);
  }
};
</code></pre>
<p class="legend right" style="margin-top:6em"><span class=arrow>&nbsp;&#x21dc;</span>Scale the image</p>

<p class=clear>All this effort raises a legitimate question: why would you want to draw an image on a canvas in the first place? What does the extra complexity of image-on-a-canvas buy you over an <code>&lt;img></code> element and some <abbr>CSS</abbr> rules? Even the &#8220;multicat&#8221; effect could be replicated with 10 overlapping <code>&lt;img></code> elements.

<p>The simple answer is, for the same reason you might want to <a href=#text>draw text on a canvas</a>. The <a href=#coordinates>canvas coordinates diagram</a> included text, lines, and shapes; the text-on-a-canvas was just one part of a larger work. A more complex diagram could easily use <code>drawImage()</code> to include icons or graphics.

<p>But wait, there&#8217;s more! You can also use canvas properties to transform an image before drawing it.

<p class=a>&#x2042;

<h2 id=transforms>Transforms</h2>

<p>Here is the same cat as before, but upside-down:</p>

<canvas id=e3 width=177 height=113></canvas>

<p>FIXME

<p class=a>&#x2042;

<h2 id=shadows>Shadows</h2>

<p class=a>&#x2042;

<h2 id=data>Canvas <span class=u>&#8227;</span> Save As&hellip;</h2>

<p class=a>&#x2042;

<h2 id=ie>What About IE?</h2>

<p class=a>&#x2042;

<p class=c>Copyright MMIX O&#8217;Reilly Media &bull; written by <a href=about.html>Mark Pilgrim</a>

<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:6jgee_nxreo><input type=hidden name=ie value=UTF-8><input name=q size=25>&nbsp;<input type=submit name=sa value=Search></div></form>
</div>
<script src=j/jquery.js></script>
<script src=j/dih5.js></script>
<script>
function draw_b() {
try {
  var b_canvas = document.getElementById("b");
  var b_context = b_canvas.getContext("2d");
  b_context.fillRect(50, 25, 150, 100);
} catch(err) {}
}

function draw_grid(ctx) {
try {
  /* vertical lines */
  for (var x = 0; x < 500; x += 10) {
    ctx.moveTo(x, 0);
    ctx.lineTo(x, 375);
  }

  /* horizontal lines */
  for (var y = 0; y < 375; y += 10) {
    ctx.moveTo(0, y);
    ctx.lineTo(500, y);
  }

  /* draw it! */
  ctx.strokeStyle = "#eee";
  ctx.stroke();
} catch(err) {}
}

function draw_arrows(ctx) {
try {
  /* x-axis */
  ctx.beginPath();
  ctx.moveTo(0, 40);
  ctx.lineTo(240, 40);
  ctx.moveTo(260, 40);
  ctx.lineTo(500, 40);
  ctx.moveTo(495, 35);
  ctx.lineTo(500, 40);
  ctx.lineTo(495, 45);

  /* y-axis */
  ctx.moveTo(60, 0);
  ctx.lineTo(60, 153);
  ctx.moveTo(60, 173);
  ctx.lineTo(60, 375);
  ctx.moveTo(65, 370);
  ctx.lineTo(60, 375);
  ctx.lineTo(55, 370);

  /* draw it! */
  ctx.strokeStyle = "#000";
  ctx.stroke();
} catch(err) {}
}

function draw_labels(ctx) {
try {
  ctx.font = "bold 12px sans-serif";
  ctx.fillText("x", 248, 43);
  ctx.fillText("y", 58, 165);
} catch(err) {}

try {
  ctx.textBaseline = "top";
  ctx.fillText("( 0 , 0 )", 8, 5);
} catch(err) {}

try {
  ctx.textAlign = "right";
  ctx.textBaseline = "bottom";
  ctx.fillText("( 500 , 375 )", 492, 370);
} catch(err) {}
}

function draw_dots(ctx) {
try {
  ctx.fillRect(0, 0, 3, 3);
  ctx.fillRect(497, 372, 3, 3);
} catch(err) {}
}

function draw_gradients(ctx) {
try {
  var d = document.getElementById("d");
  var context = d.getContext("2d");
  var my_gradient = context.createLinearGradient(0, 0, 300, 0);
  my_gradient.addColorStop(0, "black");
  my_gradient.addColorStop(1, "white");
  context.fillStyle = my_gradient;
  context.fillRect(0, 0, 300, 225);
} catch(err) {}

try {
  var d2 = document.getElementById("d2");
  var context = d2.getContext("2d");
  var my_gradient = context.createLinearGradient(0, 0, 300, 0);
  my_gradient.addColorStop(0, "black");
  my_gradient.addColorStop(1, "white");
  context.fillStyle = my_gradient;
  context.fillRect(0, 0, 300, 225);
} catch(err) {}

try {
  var d3 = document.getElementById("d3");
  var context = d3.getContext("2d");
  var my_gradient = context.createLinearGradient(0, 0, 0, 225);
  my_gradient.addColorStop(0, "black");
  my_gradient.addColorStop(1, "white");
  context.fillStyle = my_gradient;
  context.fillRect(0, 0, 300, 225);
} catch(err) {}

try {
  var d4 = document.getElementById("d4");
  var context = d4.getContext("2d");
  var my_gradient = context.createLinearGradient(0, 0, 300, 225);
  my_gradient.addColorStop(0, "black");
  my_gradient.addColorStop(1, "white");
  context.fillStyle = my_gradient;
  context.fillRect(0, 0, 300, 225);
} catch(err) {}
}

function draw_images(imagesReady) {
  var cat_canvas = document.getElementById("e");
  var cat_context = cat_canvas.getContext("2d");
  var cat_canvas2 = document.getElementById("multicat");
  var cat_context2 = cat_canvas2.getContext("2d");
  var cat_canvas3 = document.getElementById("e3");
  var cat_context3 = cat_canvas3.getContext("2d");
  cat_context3.rotate(-Math.PI);
  var cat_image = document.getElementById("cat");
  var _draw = function() {
    cat_context.drawImage(cat_image, 0, 0);
    for (var x = 0, y = 0; x < 500, y < 375; x += 50, y += 37) {
      cat_context2.drawImage(cat_image, x, y, 88, 56);
    }
    cat_context3.drawImage(cat_image, -177, -113);
  };
  if (!!imagesReady) {
    _draw();
  } else {
    window.onload = _draw;
  }
}

function draw(imagesReady) {
  var c = document.getElementById("c");
  var ctx = c.getContext("2d");
  draw_grid(ctx);
  draw_arrows(ctx);
  draw_labels(ctx);
  draw_dots(ctx);

  var c2 = document.getElementById("c2");
  ctx = c2.getContext("2d");
  draw_grid(ctx);

  var c3 = document.getElementById("c3");
  ctx = c3.getContext("2d");
  draw_grid(ctx);
  draw_arrows(ctx);

  var c4 = document.getElementById("c4");
  ctx = c4.getContext("2d");
  draw_grid(ctx);
  draw_arrows(ctx);
  draw_labels(ctx);

  var c5 = document.getElementById("c5");
  var ctx = c5.getContext("2d");
  draw_grid(ctx);
  draw_arrows(ctx);
  draw_labels(ctx);
  draw_dots(ctx);

  draw_gradients();
  draw_images(imagesReady);
}

$(document).ready(function() {
  if (!(!/*@cc_on!@*/0)) {
    window.attachEvent('onload', draw);
  } else {
    draw(false);
  }
});
</script>
